---
/**
 * GET /api/arb-download-zip?requestId=... â€” Download all attachments for a request as ZIP.
 * Requires authentication. Owner can download their own requests; ARB/Board/Admin can download any.
 */
export const prerender = false;

import { getSessionFromCookie } from '../../lib/auth';
import { getArbRequest, listArbFilesByRequest } from '../../lib/arb-db';

const runtime = Astro.locals.runtime;
const env = runtime?.env;
const session = await getSessionFromCookie(
  Astro.request.headers.get('cookie') ?? undefined,
  env?.SESSION_SECRET
);

if (!session) {
  return new Response(JSON.stringify({ error: 'Unauthorized' }), {
    status: 401,
    headers: { 'Content-Type': 'application/json' },
  });
}

const requestId = Astro.url.searchParams.get('requestId');
if (!requestId) {
  return new Response(JSON.stringify({ error: 'Missing requestId' }), {
    status: 400,
    headers: { 'Content-Type': 'application/json' },
  });
}

const db = env?.DB;
const r2 = env?.CLOURHOA_FILES;
if (!db || !r2) {
  return new Response(JSON.stringify({ error: 'Server configuration error' }), {
    status: 503,
    headers: { 'Content-Type': 'application/json' },
  });
}

const request = await getArbRequest(db, requestId);
if (!request) {
  return new Response(JSON.stringify({ error: 'Request not found' }), {
    status: 404,
    headers: { 'Content-Type': 'application/json' },
  });
}

// Check permissions: owner or ARB/Board/Admin
const allowedRoles = ['arb', 'board', 'admin', 'arb_board'];
const isOwner = request.owner_email.toLowerCase() === session.email.toLowerCase();
const isAuthorized = isOwner || allowedRoles.includes(session.role);

if (!isAuthorized) {
  return new Response(JSON.stringify({ error: 'Forbidden' }), {
    status: 403,
    headers: { 'Content-Type': 'application/json' },
  });
}

const files = await listArbFilesByRequest(db, requestId);

if (files.length === 0) {
  return new Response(JSON.stringify({ error: 'No attachments found' }), {
    status: 404,
    headers: { 'Content-Type': 'application/json' },
  });
}

// Create ZIP file using Web Streams API
// Note: Cloudflare Workers don't have native ZIP support, so we'll return a JSON with file URLs
// For a true ZIP, you'd need to use a library like @cloudflare/workers-zip or stream files client-side
// For now, we'll return a simple approach: list of files with download links

// Simple approach: return JSON with file info, client can download individually
// Or use a service that supports ZIP creation
// For simplicity, let's create a simple ZIP-like response by concatenating files
// Actually, let's use a client-side ZIP library approach or return file list

// Since we can't easily create ZIP server-side without additional dependencies,
// we'll return a JSON response with all file URLs and let the client handle ZIP creation
// OR we can use a simpler approach: return a page that triggers downloads

// For now, let's return file URLs in JSON format and handle ZIP creation client-side
const fileUrls: Array<{ filename: string; url: string }> = [];

for (const file of files) {
  try {
    const r2Keys = JSON.parse(file.r2_keys) as { originals?: string[]; review?: string[]; archive?: string[] };
    const key = r2Keys.originals?.[0] ?? r2Keys.review?.[0] ?? r2Keys.archive?.[0];
    if (key) {
      fileUrls.push({
        filename: file.filename,
        url: `/api/portal/file/${encodeURIComponent(key)}`,
      });
    }
  } catch (e) {
    console.error('Failed to parse file keys:', e);
  }
}

// Return JSON with file URLs - client will handle ZIP creation
return new Response(
  JSON.stringify({
    success: true,
    requestId,
    files: fileUrls,
  }),
  {
    status: 200,
    headers: { 'Content-Type': 'application/json' },
  }
);
