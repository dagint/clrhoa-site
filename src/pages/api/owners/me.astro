---
/**
 * GET /api/owners/me — return the current user's directory row (owner where email = session.email).
 * PUT /api/owners/me — update or create that row (name, address, phones). Body: JSON { name?, address?, phones? } (phones = array of strings).
 */
export const prerender = false;

import { requireSession, requireDb, jsonResponse } from '../../../lib/api-helpers';
import { verifyCsrfToken, getEffectiveRole } from '../../../lib/auth';
import { getOwnerByEmail, upsertOwnerByEmail, insertDirectoryLog, validateLotNumber } from '../../../lib/directory-db';

const auth = await requireSession(Astro);
if ('response' in auth) return auth.response;
const { session } = auth;

const dbResult = requireDb(Astro.locals.runtime?.env);
if ('response' in dbResult) return dbResult.response;
const { db } = dbResult;

const email = session.email.trim().toLowerCase();
const ipAddress = Astro.request.headers.get('cf-connecting-ip') ??
  Astro.request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ?? null;

// GET: return current user's owner row (or null)
if (Astro.request.method === 'GET') {
  const owner = await getOwnerByEmail(db, email);
  if (!owner) {
    return jsonResponse({ owner: null });
  }
  const phones = owner.phones ? (() => {
    try {
      const arr = JSON.parse(owner.phones) as unknown;
      return Array.isArray(arr) ? arr.filter((p): p is string => typeof p === 'string') : [];
    } catch { return []; }
  })() : (owner.phone ? [owner.phone] : []);
  return jsonResponse({
    owner: {
      id: owner.id,
      name: owner.name,
      address: owner.address,
      lot_number: owner.lot_number ?? null,
      phone: owner.phone,
      phones,
      email: owner.email,
    },
  });
}

// PUT: update or create
if (Astro.request.method !== 'PUT') {
  return jsonResponse({ error: 'Method not allowed' }, 405);
}

let body: { name?: string; address?: string; lot_number?: string; phones?: string[]; csrf_token?: string; csrfToken?: string };
try {
  body = await Astro.request.json();
} catch {
  return jsonResponse({ error: 'Invalid JSON' }, 400);
}

if (!verifyCsrfToken(session, body.csrf_token ?? body.csrfToken)) {
  return jsonResponse({ error: 'Invalid security token.' }, 403);
}

const name = typeof body.name === 'string' ? body.name.trim() || null : undefined;
const address = typeof body.address === 'string' ? body.address.trim() || null : undefined;
const lotNumber = typeof body.lot_number === 'string' ? (body.lot_number.trim() || null) : undefined;
const rawPhones = Array.isArray(body.phones) ? body.phones.filter((p): p is string => typeof p === 'string').map((p) => p.trim()).filter(Boolean) : undefined;
const MAX_PHONES = 5;
const phonesArr = rawPhones !== undefined ? rawPhones.slice(0, MAX_PHONES) : undefined;
const phonesJson = phonesArr !== undefined ? JSON.stringify(phonesArr) : undefined;

// If lot number is provided, validate format (1–25). Empty/null is allowed (optional field).
if (lotNumber !== undefined && lotNumber !== null && lotNumber !== '') {
  if (!validateLotNumber(lotNumber)) {
    return jsonResponse({ error: 'Lot number must be 1–25 when provided.' }, 400);
  }
}

const result = await upsertOwnerByEmail(db, email, { name, address, lot_number: lotNumber, phones: phonesJson });

const clientIp = Astro.clientAddress || Astro.request.headers.get('cf-connecting-ip') || null;
await insertDirectoryLog(db, session.email, '(directory info updated)', null, null, getEffectiveRole(session) ?? null, clientIp);

return jsonResponse({
  success: true,
  id: result.id,
  created: result.created,
});
---
